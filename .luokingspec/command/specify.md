# 需求分析与结构化拆分

## 命令用途

搭建新的 LuokingSpec 变更并严格验证

## 护栏规则

- 如果功能较大，需要拆解成多个子任务
- 请参考 遵守`.project-rules` 目录下面的规则，目录下每个目录都是独立的规则目录，独立规则目录下都有 `index.md` 作为规则索引，你必须根据规则索引指引相关规则。
- 用户给出的指引必须提供在 相关任务中
- 在提案阶段不要编写任何代码。只创建设计文档（tasks.md、design.md 和规范增量）。实施在批准后的应用阶段进行。

## 执行流程

### 第一步：理解需求

1. **解析用户输入**
   - 识别用户描述中的多个需求点（可能用序号、换行、分号、#号等分隔）
   - 区分需求类型：bugfix、功能更改、新功能、重构等
   - 识别涉及的领域：前端（webserver/frontend）、后端（webserver/backend）、全栈
   - 识别可拆分的需求：多个独立功能模块、可并行开发的部分、不同业务领域等

2. **查看相关代码**
   - 根据需求描述中的关键词，搜索相关代码文件（包括前后端）
   - 理解现有实现逻辑和架构，识别可能受影响的模块和文件

3. **识别业务或者流程上不明确的地方**
   - 检查需求描述中是否存在缺失的信息：功能细节、边界情况、错误处理、UI/UX 细节、数据格式和 API 接口等
   - 业务或者功能不明确，实现上（比如接口是否存在等）需要你自己梳理，不能作为不明确的地方。

### 第二步：与用户确认

1. **提出澄清问题**
   - 以清晰、结构化的方式列出需要确认的问题
   - 每个问题应该说明为什么需要确认、提供可能的选项或建议、给出推荐的回答

2. **等待用户回答**
   - 根据用户的回答更新需求理解
   - 如果仍有不明确的地方，应该继续询问，等待用户回答
   - 确认所有不明确的地方都已得到用户明确回答后，才能进入第三步

### 第三步：需求拆解

1. **评估需求复杂度**
   - 判断需求是否需要拆分成多个**独立的需求**（而不是子任务）
   - 考虑因素：涉及的文件数量、功能模块的独立性、是否可以并行开发、业务领域的差异
   - **关键原则**：拆分后的需求如果存在依赖关系，必须标明依赖关系

2. **拆分独立需求 - 核心原则**
   - 每个 Task 必须聚焦在一个单独的小功能上
   - 除了依赖关系外，每个Task应该是完全独立且可并行化的，不会存在同时修改的代码冲突等情况

- **何时必须拆分**：
  - 需求包含多个可以独立完成的功能模块
  - 需求包含可以并行开发的部分
  - 需求涉及不同业务领域或技术栈
  - 需求包含多个不相关的 bugfix 或功能点
  - 需求规模较大，需要按开发顺序逐步实现

- **拆分原则**：
  - 每个需求使用独立的 T-XXX 编号
  - 有独立的 Checklist（从 C-001 开始）
  - 如存在依赖关系需在标题中标注 `(deps: T-xxx, T-xxx)`

- **按开发顺序拆解的典型场景**：
  - **基本思路**：
    基础设施（路由、占位）→ 基础功能（跳转、数据获取）→ 核心功能（功能A、功能B、功能C）→ 增强功能（优化、边界处理）
  - **新页面/新功能模块**：先创建路由和空占位页面 → 实现页面跳转 → 实现页面基础布局 → 实现功能A → 实现功能B → 实现功能C
  - **新 API 接口**：先定义接口契约和数据结构 → 实现后端接口 → 实现前端调用 → 实现错误处理 → 实现边界情况
  - **复杂交互流程**：先实现基础流程 → 添加异常处理 → 添加优化和增强功能
  - **重构任务**：先创建新的结构 → 迁移部分功能 → 逐步替换旧实现 → 清理旧代码

- **拆解粒度标准**：
  - 每个任务应该可以在 1-2 天内完成
  - 每个任务有明确的输入和输出
  - 每个任务完成后可以独立测试和验证

- **不拆分的情况**：
  - 功能模块紧密耦合，拆分会增加复杂度
  - 需求规模适中，可以在一个任务内完成
  - 简单的 bugfix 或小的功能调整

### 第四步：生成结构化文档

1. **审查项目和创建提案**
   - 检查在项目目录下是否存在 `.luokingspec` / `.luokingspec/changes` / `.luokingspec/archive` 如果不存在则使用 `mkdir` 命令创建
   - 审查 `.luokingspec/project.md`并检查相关代码或文档（例如，通过 `rg`/`ls`）以将提案基于当前行为；注意任何需要澄清的空白。
   - 选择一个唯一的以动词开头的 `change-id`，并在 `.luokingspec/changes/<id>/` 下搭建、`tasks.md` 和 `design.md`（需要时）。
   - 当解决方案跨越多个系统、引入新模式或在提交规范之前需要权衡讨论时，在 `design.md` 中捕获架构推理。

2. **处理链接和图片资源**
   - 识别用户描述中的链接和图片，在文档中引用
   - 图片下载并保存到 `.luokingspec/changes/<id>/images` 目录（如果目录不存在则创建）
   - 图片命名规则：`T-XXX-{描述性名称}.{扩展名}`

3. **确定相关指引**
   - 根据任务类型，确定需要参考的规则文档和代码位置
   - 按照以下分类组织：前端规则、后端规则、前端Code Point、前端路由、后端Code Point、其他

4. **识别注意点**
   - 技术难点、边界情况、可能影响的其他功能模块、性能考虑、兼容性要求等

5. **生成 Task 和 Checklist**
   - 每个Task是一个独立的小功能，使用编号格式 T-001, T-002, T-003, ...
   - 每个Task内应该写功能的基本需求描述、相关指引、 注意点、checklist等。
   - 每个Task 每个需求至少包含一个 `Scenario` 并在相关时交叉引用相关能力。
   - 每个 Checklist 项应该是功能完成的验证点，有明确的验收标准，覆盖主要功能点和边界情况
   - 使用编号格式：C-001, C-002, C-003, ...

6. **严格参考文档模版**
   - Task 文档模版：`.luokingspec/template/task.md`
   - Design文档模版：`.luokingspec/template/design.md`
   - Task 示例： `.luokingspec/example/task.md`
   - Design 示例： `.luokingspec/example/design.md`
